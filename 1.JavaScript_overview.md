# JavaScript

* Number （數字）
* String （字串）
* Boolean （布林）
* Object （物件）
    * Function （函式）
    * Array （陣列）
    * Date （日期）
    * RegExp
* Null （空）
* Undefined （未定義）

## Number
數字算是「雙精確度 64 位元格式 IEEE 754 值」，因此沒有整數
```JS
0.1 + 0.2 = 0.30000000000000004
```

```JS
> parseInt("123", 10)
123
> parseInt("010", 10)
10
> parseInt("11", 2)
3
> parseInt("hello", 10)
NaN
```

NaN =  Not a Number

```JS
> NaN + 5
NaN
> isNaN(NaN)
true
> 1 / 0
Infinity
> -1 / 0
-Infinity

```

## String
```JS
> "hello".length
5
```

```JS
> "hello".charAt(0) //位置 0 的字元
h
> "hello, world".replace("hello", "goodbye") //把 hello 換成 goodbye
goodbye, world
> "hello".toUpperCase() //轉成大寫
HELLO

```

布林 (boolean) 
1. false、0、空字串 ("")、NaN、null、以及 undefined 都會成為 false
2. 所有其他的值都會成為 true
```JS
> Boolean("")
false
> Boolean(234)
true
```

運算子
```JS
> "hello" + " world"
hello world
```
如果你把一字串加到一個數字（或其他數值），會先把所有的東西轉成字串。這會讓你意想不到
```JS
> "3" + 4 + 5
345
> 3 + 4 + "5"
75
```
把一個空字串加到一個東西是個將其轉成字串的好方法之一。


雙等號運算子（等於）會進行型態強制轉換
```JS
> "dog" == "dog"
true
> 1 == true
true
```

要避免型態強制轉換，要用三等號運算子（絕對等於）：
```JS
> 1 === true
false
> true === true
true
```

判斷句
```JS
var name = "貓咪";
if (name == "狗狗") {
    name += "!";
} 
else if (name == "貓咪") {
    name += "!!";
} 
else {
    name = "!" + name;
}
name == "貓咪!!";
```


do...while：使用了do...while迴圈來持續讀取輸入，直到輸入符合指定的條件為止
```JS
while (true) {
  // 無限迴圈！
}

do {
  var input = get_input();
} while (inputIsNotValid(input));
```
在輸入有效之前，會一直重複 do 迴圈
inputIsNotValid 輸入無效，所以一但輸入有效， inputIsNotValid 就會回傳 false，然後取消迴圈


for 迴圈
```JS
for (var i=0; i<5; i++){
  // 會執行 5 次
}
```

三元運算子 (if 判斷式的縮寫)
```JS
a ? b : c
> a 如果是 ture 就執行 b，否則執行 c
```

switch 判斷式
```JS
switch (action){
  case "畫":
    draw();
    break;
  case "吃":
    eat();
    break;
  default:
    DoNoThing();
}
```

如果不加中斷
```JS
switch (a) {
  case 1:
  case 2:
    eatit(); //開始吃
    break; //中斷
  default: //預設
    donothing(); //不做任何事
}
```
如果 a 等於 1 或 2 的時候會執行 eatit 函式


## Object
建立空物件
```JS
var obj = Object();
```
or
```JS
var obj = {};
```

存取物件
```JS
obj.name = "小明";
var name = obj.name;
```

or 
```JS
obj["name"] = "小明"
var name = obj["name"]
```

```JS
obj.for = "Simon"; //語法錯誤
obj["for"] = "Simon"; //沒問題
```

`for` 是關鍵字，所以不能這樣用，而透過 `[]` 就可以允許所有字串的屬性名稱


```JS
var obj = {
  name: "胡蘿蔔", //名稱
  for: "小華", //給誰
  details: {
    //詳細資訊
    color: "橘", //顏色
    size: 12, //大小
  },
};
```
存取時也可以連在一起
```JS
obj.details.color
> 橘
obj["details"]["size"]
> 12
```


## Array
```JS
> var a = new Array();
> a[0] = "狗";
> a[1] = "貓";
> a[2] = "雞";
> a.length
3
```
array.length 就是最高索引數加一

```JS
> var a = ["狗", "貓", "雞"];
> a[100] = "狐";
> a.length
101
```

如果你查詢一個不存在的陣列索引，得到的就是 undefined：
```JS
> typeof(a[90])
undefined
```

陣列上做迴圈
```JS
for (var i = 0; i < a.length; i++) {
  //處理 a[i]
}
```
但這樣不是很有效率，因為每迴圈一次就會查詢一次 length 屬性。比較好的做法是：
```JS
for (var i = 0, len = a.length; i < len; i++) {
  //處理 a[i]
}
```

## Method
* concat 結合，會傳回加入了新項目的新陣列
* pop 會移除最後一個項目並將其傳回
* push 會在結尾加入一或多個項目（就像前面提的 ar.length 方法）
* slice 傳回副陣列
* sort 進行排序，可選擇性的接受「比較性函數」(comparison function)
* splice 讓你透過刪除一個區塊並以更多項目代替來修改陣列
* unshift 會在開頭加入一或多個項目
